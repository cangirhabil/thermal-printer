import { NextRequest, NextResponse } from "next/server";
import { exec } from "child_process";
import { promisify } from "util";
import * as net from "net";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import sharp from "sharp";

const execAsync = promisify(exec);

// USB cihaz bilgileri - KP-302H iÃ§in doÄŸrulanmÄ±ÅŸ VID/PID
const KNOWN_USB_PRINTERS = [
  { vendorId: 0x0fe6, productId: 0x811e, name: "KP-302H" }, // ICS Advent - DOÄRULANDI
  { vendorId: 0x0519, productId: 0x0003, name: "Generic Thermal" },
  { vendorId: 0x0483, productId: 0x5740, name: "USB Printer" },
];

interface PrintAttempt {
  method: string;
  details: string;
  success: boolean;
  error?: string;
}

// Platform baÄŸÄ±msÄ±z RAW yazÄ±cÄ± (Windows: KPOS_80, Linux: /dev/usb/lp0 veya CUPS)
async function tryRawPrinter(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  try {
    console.log("ğŸ–¨ï¸ Platform baÄŸÄ±msÄ±z RAW yazÄ±cÄ± deneniyor...");

    // Platform kontrolÃ¼
    const isWindows = process.platform === "win32";
    const isLinux = process.platform === "linux";
    const isMac = process.platform === "darwin";

    console.log(`ğŸ“Ÿ Platform: ${process.platform}`);

    // Bitmap hazÄ±rla
    let escposData: Buffer | null = null;

    if (imageData || textData) {
      const commands: number[] = [];

      // Initialize
      commands.push(0x1b, 0x40); // ESC @

      // GÃ¶rsel iÅŸle
      if (imageData) {
        const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
        const imageBuffer = Buffer.from(base64Data, "base64");

        const processedImage = await sharp(imageBuffer)
          .resize(576, null, { fit: "inside", withoutEnlargement: false })
          .grayscale()
          .normalise()
          .raw()
          .toBuffer({ resolveWithObject: true });

        const { data: rawData, info } = processedImage;
        const width = 576;
        const height = info.height;
        const bytesPerLine = Math.ceil(width / 8);

        const bitmapBuffer = Buffer.alloc(bytesPerLine * height);

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const pixelValue = rawData[idx];

            if (pixelValue < 128) {
              const byteIndex = y * bytesPerLine + Math.floor(x / 8);
              const bitIndex = 7 - (x % 8);
              bitmapBuffer[byteIndex] |= 1 << bitIndex;
            }
          }
        }

        const xL = width & 0xff;
        const xH = width >> 8;
        const yL = height & 0xff;
        const yH = height >> 8;

        // GS v 0 - raster bitmap
        commands.push(0x1d, 0x76, 0x30, 0x00, xL, xH, yL, yH);
        commands.push(...Array.from(bitmapBuffer));
      }

      // Metin ekle
      if (textData) {
        const textBytes = Buffer.from(textData + "\n\n", "utf8");
        commands.push(...Array.from(textBytes));
      }

      // Cut paper
      commands.push(0x1d, 0x56, 0x00); // GS V 0

      escposData = Buffer.from(commands);
    }

    if (!escposData) {
      return {
        method: "RAW Printer",
        details: "Veri yok",
        success: false,
        error: "YazdÄ±rÄ±lacak veri hazÄ±rlanamadÄ±",
      };
    }

    // Platform bazlÄ± yazdÄ±rma
    const escposArray = new Uint8Array(escposData);

    if (isWindows) {
      // Windows: KPOS_80 yazÄ±cÄ±sÄ±na RAW data gÃ¶nder
      const tempFile = path.join(os.tmpdir(), `raw-print-${Date.now()}.prn`);
      fs.writeFileSync(tempFile, escposArray);

      try {
        const { stdout, stderr } = await execAsync(
          `powershell -Command "Get-Content -Path '${tempFile}' -Encoding Byte -ReadCount 0 | Set-Content -Path '\\\\?\\UNC\\localhost\\KPOS_80' -Encoding Byte"`,
          { timeout: 10000 }
        );

        fs.unlinkSync(tempFile);

        console.log("âœ… Windows RAW yazdÄ±rma baÅŸarÄ±lÄ±!");
        return {
          method: "RAW Printer (Windows)",
          details: "KPOS_80",
          success: true,
        };
      } catch (error: any) {
        fs.unlinkSync(tempFile);
        console.log(`âŒ Windows RAW hatasÄ±: ${error.message}`);

        // Alternatif: copy komutu ile dene
        try {
          const tempFile2 = path.join(
            os.tmpdir(),
            `raw-print-${Date.now()}.prn`
          );
          fs.writeFileSync(tempFile2, escposArray);

          await execAsync(`copy /b "${tempFile2}" "\\\\localhost\\KPOS_80"`, {
            timeout: 10000,
          });
          fs.unlinkSync(tempFile2);

          console.log("âœ… Windows COPY komutu ile baÅŸarÄ±lÄ±!");
          return {
            method: "RAW Printer (Windows/COPY)",
            details: "KPOS_80",
            success: true,
          };
        } catch (e: any) {
          console.log(`âŒ COPY komutu da baÅŸarÄ±sÄ±z: ${e.message}`);
        }
      }
    } else if (isLinux) {
      // Linux: /dev/usb/lp0 veya CUPS
      const devicePaths = ["/dev/usb/lp0", "/dev/lp0", "/dev/usblp0"];

      for (const devicePath of devicePaths) {
        try {
          fs.writeFileSync(devicePath, escposArray);
          console.log(`âœ… Linux RAW yazdÄ±rma baÅŸarÄ±lÄ±: ${devicePath}`);
          return {
            method: "RAW Printer (Linux)",
            details: devicePath,
            success: true,
          };
        } catch (error: any) {
          console.log(`âŒ ${devicePath} hatasÄ±: ${error.message}`);
          continue;
        }
      }

      // CUPS ile dene
      try {
        const tempFile = `/tmp/thermal-print-${Date.now()}.prn`;
        fs.writeFileSync(tempFile, escposArray);
        await execAsync(`lp -d kp-302h "${tempFile}"`, { timeout: 10000 });
        fs.unlinkSync(tempFile);

        console.log("âœ… Linux CUPS yazdÄ±rma baÅŸarÄ±lÄ±!");
        return {
          method: "RAW Printer (Linux/CUPS)",
          details: "kp-302h",
          success: true,
        };
      } catch (error: any) {
        console.log(`âŒ CUPS hatasÄ±: ${error.message}`);
      }
    } else if (isMac) {
      // macOS: CUPS kullan
      try {
        const tempFile = `/tmp/thermal-print-${Date.now()}.prn`;
        fs.writeFileSync(tempFile, escposArray);
        await execAsync(`lp -d KP-302H "${tempFile}"`, { timeout: 10000 });
        fs.unlinkSync(tempFile);

        console.log("âœ… macOS CUPS yazdÄ±rma baÅŸarÄ±lÄ±!");
        return {
          method: "RAW Printer (macOS/CUPS)",
          details: "KP-302H",
          success: true,
        };
      } catch (error: any) {
        console.log(`âŒ macOS CUPS hatasÄ±: ${error.message}`);
      }
    }

    return {
      method: "RAW Printer",
      details: `Platform: ${process.platform}`,
      success: false,
      error: "HiÃ§bir RAW yazÄ±cÄ± yÃ¶ntemi Ã§alÄ±ÅŸmadÄ±",
    };
  } catch (error: any) {
    console.log(`âŒ RAW Printer hatasÄ±: ${error.message}`);
    return {
      method: "RAW Printer",
      details: "Hata",
      success: false,
      error: error.message,
    };
  }
}

// Direkt USB yazdÄ±rma (Windows iÃ§in PowerShell USB RAW yazdÄ±rma)
async function tryDirectUSB(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  try {
    console.log("ğŸ”Œ USB yazÄ±cÄ± aranÄ±yor (Windows USB/USBPRINT)...");

    // Ã–nce USB cihazlarÄ±nÄ± kontrol et (Class filtresi olmadan)
    let stdout = "";
    try {
      const result = await execAsync(
        "powershell -Command \"Get-PnpDevice | Where-Object {$_.Status -eq 'OK' -and ($_.FriendlyName -like '*KP*' -or $_.FriendlyName -like '*302*')} | Select-Object FriendlyName,InstanceId,Class | ConvertTo-Json\""
      );
      stdout = result.stdout;
    } catch (error: any) {
      console.log(
        "âš ï¸ USB cihaz tarama hatasÄ±, Windows yazÄ±cÄ± listesini deniyorum..."
      );

      // Alternatif: DoÄŸrudan KPOS_80 yazÄ±cÄ±sÄ±nÄ± kullan
      try {
        const printerResult = await execAsync(
          "powershell -Command \"Get-Printer | Where-Object {$_.Name -like '*KPOS*' -or $_.Name -like '*KP*'} | Select-Object Name | ConvertTo-Json\""
        );

        if (printerResult.stdout.trim()) {
          const printers = JSON.parse(printerResult.stdout);
          const printerList = Array.isArray(printers) ? printers : [printers];

          if (printerList.length > 0) {
            const printerName = printerList[0].Name;
            console.log(`âœ… Windows yazÄ±cÄ± bulundu: ${printerName}`);
            // Windows yazÄ±cÄ± Ã¼zerinden yazdÄ±rmayÄ± dene
            return await tryWindowsPrinter(imageData, textData);
          }
        }
      } catch (e) {
        console.log("âŒ Windows yazÄ±cÄ± da bulunamadÄ±");
      }
    }

    if (!stdout || !stdout.trim()) {
      console.log("âŒ USB yazÄ±cÄ± bulunamadÄ±");
      return {
        method: "Direct USB",
        details: "USB yazÄ±cÄ± bulunamadÄ±",
        success: false,
        error: "KP-302H USB cihazÄ± bulunamadÄ±",
      };
    }

    const devices = JSON.parse(stdout);
    const deviceList = Array.isArray(devices) ? devices : [devices];

    console.log(`ğŸ“± ${deviceList.length} USB yazÄ±cÄ± bulundu`);

    for (const device of deviceList) {
      const deviceName = device.FriendlyName;
      console.log(`ğŸ–¨ï¸ Deneniyor: ${deviceName}`);

      try {
        // GÃ¶rsel iÅŸleme
        let bitmapBuffer: Buffer | null = null;
        let width = 576;
        let height = 0;

        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          const processedImage = await sharp(imageBuffer)
            .resize(576, null, { fit: "inside", withoutEnlargement: false })
            .grayscale()
            .normalise()
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = processedImage;
          width = 576;
          height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          bitmapBuffer = Buffer.alloc(bytesPerLine * height);

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = y * width + x;
              const pixelValue = rawData[idx];

              if (pixelValue < 128) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8);
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }
        }

        // USB Raw yazdÄ±rma iÃ§in C# script kullan
        const bitmapPath = bitmapBuffer
          ? path.join(os.tmpdir(), `usb-bitmap-${Date.now()}.bin`)
          : "";
        if (bitmapBuffer) {
          fs.writeFileSync(bitmapPath, new Uint8Array(bitmapBuffer));
        }

        const csScriptPath = path.join(
          os.tmpdir(),
          `usb-print-${Date.now()}.cs`
        );

        const xL = width & 0xff;
        const xH = width >> 8;
        const yL = height & 0xff;
        const yH = height >> 8;

        const imageCommand = bitmapBuffer
          ? `
            // Initialize
            data.Add(0x1B); data.Add(0x40); // ESC @
            
            // Image command - GS v 0
            data.Add(0x1D); data.Add(0x76); data.Add(0x30); data.Add(0x00);
            data.Add(${xL}); data.Add(${xH}); data.Add(${yL}); data.Add(${yH});
            
            // Bitmap data
            byte[] bitmapData = System.IO.File.ReadAllBytes(@"${bitmapPath.replace(
              /\\/g,
              "\\\\"
            )}");
            data.AddRange(bitmapData);
          `
          : "";

        const textCommand = textData
          ? `
            // Text
            byte[] textBytes = System.Text.Encoding.UTF8.GetBytes("${textData
              .replace(/"/g, '\\"')
              .replace(/\n/g, "\\n")}\\n\\n");
            data.AddRange(textBytes);
          `
          : "";

        const csScript = `
using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;

class USBPrinter {
    [DllImport("kernel32.dll", SetLastError = true, CharSet = CharSet.Auto)]
    static extern IntPtr CreateFile(string lpFileName, uint dwDesiredAccess, uint dwShareMode, 
        IntPtr lpSecurityAttributes, uint dwCreationDisposition, uint dwFlagsAndAttributes, IntPtr hTemplateFile);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool WriteFile(IntPtr hFile, byte[] lpBuffer, uint nNumberOfBytesToWrite, 
        out uint lpNumberOfBytesWritten, IntPtr lpOverlapped);
    
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool CloseHandle(IntPtr hObject);
    
    const uint GENERIC_WRITE = 0x40000000;
    const uint OPEN_EXISTING = 3;
    
    static void Main() {
        try {
            List<byte> data = new List<byte>();
            
            ${imageCommand}
            ${textCommand}
            
            // Cut paper
            data.Add(0x1D); data.Add(0x56); data.Add(0x00); // GS V 0
            
            // USB cihaz yolunu bul (KP-302H iÃ§in)
            string usbPath = "\\\\\\\\.\\\\USBPRINT001";
            
            // Alternatif yollarÄ± dene
            string[] possiblePaths = new string[] {
                "\\\\\\\\.\\\\USBPRINT001",
                "\\\\\\\\.\\\\USB001",
                "\\\\\\\\.\\\\USB002",
                "\\\\\\\\.\\\\USB003"
            };
            
            IntPtr handle = IntPtr.Zero;
            string workingPath = null;
            
            foreach (string testPath in possiblePaths) {
                handle = CreateFile(testPath, GENERIC_WRITE, 0, IntPtr.Zero, OPEN_EXISTING, 0, IntPtr.Zero);
                if (handle.ToInt64() != -1) {
                    workingPath = testPath;
                    break;
                }
            }
            
            if (handle.ToInt64() == -1) {
                Console.Error.WriteLine("USB cihaz aÃ§Ä±lamadÄ±");
                Environment.Exit(1);
            }
            
            byte[] buffer = data.ToArray();
            uint bytesWritten;
            
            if (!WriteFile(handle, buffer, (uint)buffer.Length, out bytesWritten, IntPtr.Zero)) {
                Console.Error.WriteLine("Yazma hatasÄ±");
                CloseHandle(handle);
                Environment.Exit(1);
            }
            
            CloseHandle(handle);
            Console.WriteLine("SUCCESS:" + workingPath);
            Environment.Exit(0);
        } catch (Exception ex) {
            Console.Error.WriteLine("Hata: " + ex.Message);
            Environment.Exit(1);
        }
    }
}
`;

        fs.writeFileSync(csScriptPath, csScript, "utf8");

        // C# script'i derle ve Ã§alÄ±ÅŸtÄ±r
        const { stdout: csOutput, stderr: csError } = await execAsync(
          `powershell -Command "Add-Type -TypeDefinition (Get-Content '${csScriptPath}' -Raw) -Language CSharp; [USBPrinter]::Main()"`,
          { timeout: 10000 }
        );

        // Cleanup
        try {
          if (bitmapPath) fs.unlinkSync(bitmapPath);
        } catch {}
        try {
          fs.unlinkSync(csScriptPath);
        } catch {}

        if (csOutput.includes("SUCCESS")) {
          const usbPath = csOutput.split(":")[1]?.trim() || "USB";
          console.log(`âœ… USB yazdÄ±rma baÅŸarÄ±lÄ±: ${deviceName} (${usbPath})`);
          return {
            method: "Direct USB",
            details: `${deviceName} (${usbPath})`,
            success: true,
          };
        } else if (csError) {
          console.log(`âŒ ${deviceName} hatasÄ±: ${csError}`);
        }
      } catch (error: any) {
        console.log(`âŒ ${deviceName} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }

    return {
      method: "Direct USB",
      details: "USB yazdÄ±rma baÅŸarÄ±sÄ±z",
      success: false,
      error: "TÃ¼m USB cihazlarÄ± denendi, hiÃ§biri Ã§alÄ±ÅŸmadÄ±",
    };
  } catch (error: any) {
    console.log(`âŒ USB hata: ${error.message}`);
    return {
      method: "Direct USB",
      details: "USB eriÅŸim hatasÄ±",
      success: false,
      error: error.message,
    };
  }
}

// USB/Serial portlarÄ± dene
async function trySerialPorts(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  try {
    const { SerialPort } = await import("serialport");
    const ports = await SerialPort.list();

    console.log(`ğŸ” ${ports.length} serial port bulundu`);

    // Her portu dene
    for (const portInfo of ports) {
      const portPath = portInfo.path;
      console.log(`ğŸ”Œ Port deneniyor: ${portPath}`);

      try {
        // GÃ¶rsel iÅŸleme
        let bitmapBuffer: Buffer | null = null;
        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          const processedImage = await sharp(imageBuffer)
            .resize(576, null, { fit: "inside", withoutEnlargement: false })
            .grayscale()
            .normalise()
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = processedImage;
          const width = 576;
          const height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          bitmapBuffer = Buffer.alloc(bytesPerLine * height);

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = y * width + x;
              const pixelValue = rawData[idx];

              if (pixelValue < 128) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8);
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }
        }

        // PowerShell script oluÅŸtur
        const bitmapPath = path.join(
          os.tmpdir(),
          `thermal-auto-${Date.now()}.bin`
        );
        const scriptPath = path.join(
          os.tmpdir(),
          `thermal-auto-${Date.now()}.ps1`
        );

        if (bitmapBuffer) {
          fs.writeFileSync(bitmapPath, new Uint8Array(bitmapBuffer));
        }

        const escInit = "1B 40"; // ESC @
        const cutPaper = "1D 56 00"; // GS V 0

        let imageCommands = "";
        if (bitmapBuffer) {
          const width = 576;
          const height = Math.floor(bitmapBuffer.length / Math.ceil(width / 8));
          const xL = width & 0xff;
          const xH = width >> 8;
          const yL = height & 0xff;
          const yH = height >> 8;

          imageCommands = `
  # GÃ¶rsel yazdÄ±r
  $imageCommand = [byte[]](0x1D, 0x76, 0x30, 0x00, ${xL}, ${xH}, ${yL}, ${yH})
  $port.Write($imageCommand, 0, $imageCommand.Length)
  Start-Sleep -Milliseconds 50
  
  $bitmapData = [System.IO.File]::ReadAllBytes("${bitmapPath.replace(
    /\\/g,
    "\\\\"
  )}")
  $port.Write($bitmapData, 0, $bitmapData.Length)
  Start-Sleep -Milliseconds 100
`;
        }

        let textCommands = "";
        if (textData) {
          const escapedText = textData.replace(/"/g, '`"').replace(/\$/g, "`$");
          textCommands = `
  # Metin yazdÄ±r
  $textBytes = [System.Text.Encoding]::GetEncoding(857).GetBytes("${escapedText}\n\n")
  $port.Write($textBytes, 0, $textBytes.Length)
  Start-Sleep -Milliseconds 100
`;
        }

        const psScript = `
$ErrorActionPreference = "Stop"

try {
    $port = New-Object System.IO.Ports.SerialPort("${portPath}", 9600, "None", 8, "One")
    $port.Handshake = [System.IO.Ports.Handshake]::RequestToSend
    $port.ReadTimeout = 1000
    $port.WriteTimeout = 1000
    
    $port.Open()
    
    if (-not $port.IsOpen) {
        Write-Error "Port aÃ§Ä±lamadÄ±"
        exit 1
    }
    
    # Initialize
    $initBytes = [byte[]](${escInit
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($initBytes, 0, $initBytes.Length)
    Start-Sleep -Milliseconds 50
    ${imageCommands}${textCommands}
    # Cut paper
    $cutBytes = [byte[]](${cutPaper
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($cutBytes, 0, $cutBytes.Length)
    Start-Sleep -Milliseconds 100
    
    $port.Close()
    Write-Output "SUCCESS"
    exit 0
} catch {
    Write-Error $_.Exception.Message
    if ($port -and $port.IsOpen) {
        $port.Close()
    }
    exit 1
}
`;

        fs.writeFileSync(scriptPath, psScript, "utf8");

        const { stdout, stderr } = await execAsync(
          `powershell -ExecutionPolicy Bypass -File "${scriptPath}"`,
          { timeout: 10000 }
        );

        // Cleanup
        try {
          fs.unlinkSync(bitmapPath);
        } catch {}
        try {
          fs.unlinkSync(scriptPath);
        } catch {}

        if (stdout.includes("SUCCESS")) {
          console.log(`âœ… ${portPath} baÅŸarÄ±lÄ±!`);
          return {
            method: "Serial/USB",
            details: portPath,
            success: true,
          };
        }
      } catch (error: any) {
        console.log(`âŒ ${portPath} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }

    return {
      method: "Serial/USB",
      details: "HiÃ§bir port Ã§alÄ±ÅŸmadÄ±",
      success: false,
      error: "TÃ¼m portlar denendi, hiÃ§biri Ã§alÄ±ÅŸmadÄ±",
    };
  } catch (error: any) {
    return {
      method: "Serial/USB",
      details: "SerialPort yÃ¼klenemedi",
      success: false,
      error: error.message,
    };
  }
}

// Network baÄŸlantÄ±sÄ±nÄ± dene
async function tryNetwork(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  const ips = ["192.168.2.211", "192.168.1.100", "192.168.0.100"];
  const ports = [9100, 9101, 9102];

  for (const ip of ips) {
    for (const port of ports) {
      try {
        console.log(`ğŸŒ Network deneniyor: ${ip}:${port}`);

        const socket = new net.Socket();
        await new Promise<void>((resolve, reject) => {
          socket.setTimeout(2000);
          socket.on("connect", () => resolve());
          socket.on("timeout", () => reject(new Error("Timeout")));
          socket.on("error", (err) => reject(err));
          socket.connect(port, ip);
        });

        // BaÄŸlantÄ± baÅŸarÄ±lÄ±, yazdÄ±r
        const escInit = new Uint8Array([0x1b, 0x40]); // ESC @
        const cutPaper = new Uint8Array([0x1d, 0x56, 0x00]); // GS V 0

        socket.write(escInit);

        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          const processedImage = await sharp(imageBuffer)
            .resize(576, null, { fit: "inside", withoutEnlargement: false })
            .grayscale()
            .normalise()
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = processedImage;
          const width = 576;
          const height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          const bitmapBuffer = Buffer.alloc(bytesPerLine * height);

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = y * width + x;
              const pixelValue = rawData[idx];

              if (pixelValue < 128) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8);
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }

          const xL = width & 0xff;
          const xH = width >> 8;
          const yL = height & 0xff;
          const yH = height >> 8;

          const imageCommand = new Uint8Array([
            0x1d,
            0x76,
            0x30,
            0x00,
            xL,
            xH,
            yL,
            yH,
          ]);
          socket.write(imageCommand);
          socket.write(new Uint8Array(bitmapBuffer));
        }

        if (textData) {
          const textEncoder = new TextEncoder();
          socket.write(textEncoder.encode(textData + "\n\n"));
        }

        socket.write(cutPaper);
        socket.end();

        console.log(`âœ… Network ${ip}:${port} baÅŸarÄ±lÄ±!`);
        return {
          method: "Network",
          details: `${ip}:${port}`,
          success: true,
        };
      } catch (error: any) {
        console.log(`âŒ Network ${ip}:${port} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }
  }

  return {
    method: "Network",
    details: "HiÃ§bir network adresi Ã§alÄ±ÅŸmadÄ±",
    success: false,
    error: "TÃ¼m network adresleri denendi",
  };
}

// Windows yazÄ±cÄ±yÄ± dene
async function tryWindowsPrinter(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  try {
    console.log("ğŸ–¨ï¸ Windows yazÄ±cÄ±larÄ± deneniyor");

    const { stdout } = await execAsync(
      'powershell -Command "Get-Printer | Select-Object Name | ConvertTo-Json"'
    );

    const printers = JSON.parse(stdout);
    const printerArray = Array.isArray(printers) ? printers : [printers];

    for (const printer of printerArray) {
      const printerName = printer.Name;
      console.log(`ğŸ–¨ï¸ Windows yazÄ±cÄ± deneniyor: ${printerName}`);

      try {
        // Windows Printer desteklenmedi - bu yÃ¶ntem devre dÄ±ÅŸÄ±
        console.log(`âš ï¸ Windows Printer API desteklenmiyor: ${printerName}`);
        continue;
      } catch (error: any) {
        console.log(
          `âŒ Windows yazÄ±cÄ± ${printerName} baÅŸarÄ±sÄ±z: ${error.message}`
        );
        continue;
      }
    }

    return {
      method: "Windows Printer",
      details: "HiÃ§bir yazÄ±cÄ± Ã§alÄ±ÅŸmadÄ±",
      success: false,
      error: "TÃ¼m Windows yazÄ±cÄ±larÄ± denendi",
    };
  } catch (error: any) {
    return {
      method: "Windows Printer",
      details: "Windows yazÄ±cÄ± listesi alÄ±namadÄ±",
      success: false,
      error: error.message,
    };
  }
}

export async function POST(request: NextRequest) {
  try {
    const { imageData, textData } = await request.json();

    console.log("========================================");
    console.log("ğŸ¤– OTOMATÄ°K YAZDIRMA BAÅLATILDI");
    console.log("GÃ¶rsel:", !!imageData);
    console.log("Metin:", !!textData);
    console.log("========================================");

    const attempts: PrintAttempt[] = [];

    // 1. RAW Printer (Platform baÄŸÄ±msÄ±z - Windows/Linux/macOS)
    console.log("\nï¿½ï¸ 1. RAW PRINTER (KPOS_80) DENENIYOR...");
    const rawResult = await tryRawPrinter(imageData, textData);
    attempts.push(rawResult);
    if (rawResult.success) {
      return NextResponse.json({
        success: true,
        message: `âœ… ${rawResult.method} Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${rawResult.details}`,
        method: rawResult.method,
        details: rawResult.details,
        attempts,
      });
    }

    // 2. Serial/COM portlarÄ± dene
    console.log("\nğŸ” 2. SERIAL/COM PORTLARI DENENIYOR...");
    const serialResult = await trySerialPorts(imageData, textData);
    attempts.push(serialResult);
    if (serialResult.success) {
      return NextResponse.json({
        success: true,
        message: `âœ… ${serialResult.method} Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${serialResult.details}`,
        method: serialResult.method,
        details: serialResult.details,
        attempts,
      });
    }

    // 3. Network baÄŸlantÄ±sÄ±nÄ± dene
    console.log("\nğŸŒ 3. NETWORK BAÄLANTISI DENENIYOR...");
    const networkResult = await tryNetwork(imageData, textData);
    attempts.push(networkResult);
    if (networkResult.success) {
      return NextResponse.json({
        success: true,
        message: `âœ… ${networkResult.method} Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${networkResult.details}`,
        method: networkResult.method,
        details: networkResult.details,
        attempts,
      });
    }

    // HiÃ§bir yÃ¶ntem Ã§alÄ±ÅŸmadÄ±
    console.log("\nâŒ HÄ°Ã‡BÄ°R YÃ–NTEM Ã‡ALIÅMADI");
    console.log("Denemeler:", attempts);
    console.log("\nğŸ’¡ Ã–NERÄ°:");
    console.log("  - Windows: KPOS_80 yazÄ±cÄ±sÄ±nÄ±n yÃ¼klÃ¼ olduÄŸundan emin olun");
    console.log("  - Linux: /dev/usb/lp0 veya CUPS yazÄ±cÄ±sÄ±nÄ± kontrol edin");
    console.log("  - Alternatif: Network IP adresini ayarlayÄ±n");

    return NextResponse.json({
      success: false,
      error: "YazÄ±cÄ± bulunamadÄ± veya hiÃ§bir baÄŸlantÄ± yÃ¶ntemi Ã§alÄ±ÅŸmadÄ±",
      attempts,
    });
  } catch (error: any) {
    console.error("========================================");
    console.error("âŒ OTOMATÄ°K YAZDIRMA HATASI");
    console.error("Hata:", error.message);
    console.error("========================================");

    return NextResponse.json({
      success: false,
      error: error.message || "Bilinmeyen hata",
    });
  }
}
