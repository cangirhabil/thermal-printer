import { NextRequest, NextResponse } from "next/server";
import * as net from "net";
import sharp from "sharp";

// GÃ¼venli ThermalPrinter kÃ¼tÃ¼phanesi
async function getThermalPrinter() {
  try {
    const { ThermalPrinter, PrinterTypes } = await import("node-thermal-printer");
    return { ThermalPrinter, PrinterTypes };
  } catch (error) {
    console.error("ThermalPrinter yÃ¼klenemedi:", error);
    return null;
  }
}

interface PrintAttempt {
  method: string;
  details: string;
  success: boolean;
  error?: string;
}

interface TextOptions {
  fontSize?: "small" | "normal" | "large" | "xlarge";
  fontType?: "A" | "B";
  alignment?: "left" | "center" | "right";
  bold?: boolean;
  underline?: boolean;
  lineSpacing?: number;
  leftMargin?: number;
  topSpacing?: number;
  bottomSpacing?: number;
}

// ==========================================
// COM PORT - Serial Communication (Priority 1)
// node-thermal-printer kÃ¼tÃ¼phanesi ile gÃ¼venli yazdÄ±rma
// ==========================================
async function trySerialPorts(
  imageData: string | null,
  textData: string,
  textOptions?: TextOptions
): Promise<PrintAttempt> {
  try {
    const printerLib = await getThermalPrinter();
    if (!printerLib) {
      return {
        method: "Serial/USB",
        details: "ThermalPrinter kÃ¼tÃ¼phanesi yÃ¼klenemedi",
        success: false,
        error: "node-thermal-printer paketi bulunamadÄ±",
      };
    }

    const { ThermalPrinter, PrinterTypes } = printerLib;
    const { SerialPort } = await import("serialport");
    const ports = await SerialPort.list();

    console.log(`ğŸ” ${ports.length} serial port bulundu`);

    // Her portu dene
    for (const portInfo of ports) {
      const portPath = portInfo.path;
      console.log(`ğŸ”Œ Port deneniyor: ${portPath}`);

      try {
        // ThermalPrinter yapÄ±landÄ±rmasÄ±
        const printer = new ThermalPrinter({
          type: PrinterTypes.EPSON, // ESC/POS uyumlu
          interface: portPath,
          characterSet: "TURKEY",
          removeSpecialCharacters: false,
          lineCharacter: "-",
          options: {
            timeout: 5000,
          },
        });

        // BaÄŸlantÄ± testi
        const isConnected = await printer.isPrinterConnected();
        if (!isConnected) {
          console.log(`âŒ ${portPath} baÄŸlantÄ± baÅŸarÄ±sÄ±z`);
          continue;
        }

        console.log(`âœ… ${portPath} baÄŸlantÄ± baÅŸarÄ±lÄ±`);

        // YazÄ±cÄ±yÄ± baÅŸlat
        printer.clear();

        // GÃ¶rsel iÅŸleme
        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          // KP-302: 576 dots geniÅŸlik (72mm x 8 dots/mm)
          const processedImage = await sharp(imageBuffer)
            .resize(576, null, {
              fit: "inside",
              withoutEnlargement: false,
              kernel: sharp.kernel.lanczos3,
            })
            .grayscale()
            .normalise()
            .threshold(128, { greyscale: false })
            .png()
            .toBuffer();

          // GÃ¶rseli yazdÄ±r
          await printer.printImage(processedImage);
          printer.newLine();
        }

        // Metin yazdÄ±rma
        if (textData && textData.trim().length > 0) {
          // Ãœst boÅŸluk
          const topSpacing = textOptions?.topSpacing || 2;
          for (let i = 0; i < topSpacing; i++) {
            printer.newLine();
          }

          // Sol kenar boÅŸluÄŸu (leftMargin piksel -> karakter dÃ¶nÃ¼ÅŸÃ¼mÃ¼)
          const leftMargin = textOptions?.leftMargin || 0;
          const leftMarginChars = Math.floor(leftMargin / 12); // ~12 piksel = 1 karakter

          // SatÄ±r aralÄ±ÄŸÄ± ayarÄ±
          const lineSpacing = textOptions?.lineSpacing || 30;
          printer.setLineSpacing(lineSpacing);

          // Font tipi
          if (textOptions?.fontType === "B") {
            printer.setTypeFontB();
          } else {
            printer.setTypeFontA();
          }

          // Hizalama
          if (textOptions?.alignment === "center") {
            printer.alignCenter();
          } else if (textOptions?.alignment === "right") {
            printer.alignRight();
          } else {
            printer.alignLeft();
          }

          // KalÄ±n yazÄ±
          if (textOptions?.bold) {
            printer.bold(true);
          }

          // AltÄ± Ã§izili
          if (textOptions?.underline) {
            printer.underline(true);
          }

          // YazÄ± boyutu
          if (textOptions?.fontSize === "small") {
            printer.setTextNormal();
          } else if (textOptions?.fontSize === "normal") {
            printer.setTextDoubleHeight();
            printer.setTextDoubleWidth();
          } else if (textOptions?.fontSize === "large") {
            printer.setTextQuadArea();
          } else if (textOptions?.fontSize === "xlarge") {
            printer.setTextQuadArea();
            printer.bold(true); // Extra emphasis
          }

          // Sol kenar boÅŸluÄŸu ekle
          const leftPadding = " ".repeat(leftMarginChars);
          
          // Metni satÄ±r satÄ±r yazdÄ±r
          const lines = textData.split("\n");
          for (const line of lines) {
            printer.println(leftPadding + line);
          }

          // AyarlarÄ± sÄ±fÄ±rla
          printer.setTextNormal();
          printer.bold(false);
          printer.underline(false);
          printer.alignLeft();
          printer.setTypeFontA();
          printer.setLineSpacing(30); // VarsayÄ±lan

          // Alt boÅŸluk
          const bottomSpacing = textOptions?.bottomSpacing || 3;
          for (let i = 0; i < bottomSpacing; i++) {
            printer.newLine();
          }
        }

        // KaÄŸÄ±t ilerletme ve kesme
        printer.newLine();
        printer.newLine();
        printer.newLine();
        printer.cut();

        // YazdÄ±r
        await printer.execute();
        
        console.log(`âœ… ${portPath} yazdÄ±rma baÅŸarÄ±lÄ±!`);
        return {
          method: "Serial/USB (ThermalPrinter)",
          details: portPath,
          success: true,
        };
      } catch (error: any) {
        console.log(`âŒ ${portPath} yazdÄ±rma hatasÄ±: ${error.message}`);
        continue;
      }
    }

    return {
      method: "Serial/USB",
      details: "HiÃ§bir port Ã§alÄ±ÅŸmadÄ±",
      success: false,
      error: "TÃ¼m portlar denendi, hiÃ§biri Ã§alÄ±ÅŸmadÄ±",
    };
  } catch (error: any) {
    return {
      method: "Serial/USB",
      details: "SerialPort yÃ¼klenemedi",
      success: false,
      error: error.message,
    };
  }
}
  try {
    const { SerialPort } = await import("serialport");
    const ports = await SerialPort.list();

    console.log(`ğŸ” ${ports.length} serial port bulundu`);

    // Her portu dene
    for (const portInfo of ports) {
      const portPath = portInfo.path;
      console.log(`ğŸ”Œ Port deneniyor: ${portPath}`);

      try {
        // GÃ¶rsel iÅŸleme - KP-302 iÃ§in optimize edilmiÅŸ
        let bitmapBuffer: Buffer | null = null;
        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          // KP-302: 576 dots geniÅŸlik (72mm x 8 dots/mm)
          // Sharp ile iÅŸleme - termal yazÄ±cÄ± iÃ§in optimize
          const processedImage = await sharp(imageBuffer)
            .resize(576, null, {
              fit: "inside",
              withoutEnlargement: false,
              kernel: sharp.kernel.lanczos3, // Daha yumuÅŸak kenarlar
            })
            .grayscale()
            .normalise() // Kontrast normalleÅŸtirme
            .threshold(128, { greyscale: false }) // Binary threshold (siyah-beyaz)
            .toBuffer();

          // Sharp'Ä±n PNG Ã§Ä±ktÄ±sÄ±nÄ± yeniden okuyup raw'a Ã§evir
          const rawImage = await sharp(processedImage)
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = rawImage;
          const width = Math.min(info.width, 576); // Maksimum 576
          const height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          bitmapBuffer = Buffer.alloc(bytesPerLine * height);
          bitmapBuffer.fill(0); // Temiz baÅŸlangÄ±Ã§

          // Piksel dÃ¶nÃ¼ÅŸÃ¼mÃ¼ - her pikseli kontrol et
          // ESC/POS standardÄ±: MSB first (soldan saÄŸa, 7->0 bit sÄ±rasÄ±)
          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = (y * info.width + x) * info.channels;
              const pixelValue = rawData[idx];

              // Sharp threshold: Siyah=0, Beyaz=255
              // Thermal printer: Bit 1=Siyah, Bit 0=Beyaz
              if (pixelValue < 128) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8); // MSB first
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }
        }

        // PowerShell script oluÅŸtur
        const bitmapPath = path.join(
          os.tmpdir(),
          `thermal-auto-${Date.now()}.bin`
        );
        const scriptPath = path.join(
          os.tmpdir(),
          `thermal-auto-${Date.now()}.ps1`
        );

        let imageWidth = 0;
        let imageHeight = 0;

        if (bitmapBuffer) {
          // Bitmap boyutlarÄ±nÄ± hesapla
          const bytesPerLine = Math.ceil(576 / 8); // 72 byte per line
          imageWidth = 576;
          imageHeight = Math.floor(bitmapBuffer.length / bytesPerLine);

          console.log(
            `ğŸ“ Bitmap boyutu: ${imageWidth}x${imageHeight}, Data: ${bitmapBuffer.length} bytes`
          );
          fs.writeFileSync(bitmapPath, Uint8Array.from(bitmapBuffer));
        }

        const escInit = "1B 40"; // ESC @
        const cutPaper = "1D 56 00"; // GS V 0

        let imageCommands = "";
        if (bitmapBuffer && imageWidth > 0 && imageHeight > 0) {
          // Byte cinsinden geniÅŸlik hesabÄ±
          const widthBytes = Math.ceil(imageWidth / 8);
          const xL = widthBytes & 0xff;
          const xH = (widthBytes >> 8) & 0xff;
          const yL = imageHeight & 0xff;
          const yH = (imageHeight >> 8) & 0xff;

          imageCommands = `
  # GÃ¶rsel yazdÄ±r - GS v 0 m komutu (ESC/POS standart)
  # m=0: Normal mode, xL xH = geniÅŸlik (byte), yL yH = yÃ¼kseklik (dot)
  Write-Host "Gorsel yazdiriliyor: ${imageWidth}x${imageHeight} (${widthBytes} bytes/satir)"
  $imageCommand = [byte[]](0x1D, 0x76, 0x30, 0x00, ${xL}, ${xH}, ${yL}, ${yH})
  $port.Write($imageCommand, 0, $imageCommand.Length)
  Start-Sleep -Milliseconds 100
  
  $bitmapData = [System.IO.File]::ReadAllBytes("${bitmapPath.replace(
    /\\/g,
    "\\\\"
  )}")
  Write-Host "Bitmap data boyutu:" $bitmapData.Length "bytes (beklenen:" ($imageCommand[4] + $imageCommand[5]*256) * ($imageCommand[6] + $imageCommand[7]*256) ")"
  $port.Write($bitmapData, 0, $bitmapData.Length)
  Start-Sleep -Milliseconds 200
`;
        }

        let textCommands = "";
        if (textData && textData.trim().length > 0) {
          const escapedText = textData
            .replace(/"/g, '`"')
            .replace(/\$/g, "`$")
            .replace(/\r/g, "");
          
          // YazÄ± boyutu ayarÄ±
          let sizeCode = "0x00"; // Normal (1x1)
          if (textOptions?.fontSize === "small") {
            sizeCode = "0x00"; // 1x1
          } else if (textOptions?.fontSize === "normal") {
            sizeCode = "0x11"; // 2x2
          } else if (textOptions?.fontSize === "large") {
            sizeCode = "0x22"; // 3x3
          } else if (textOptions?.fontSize === "xlarge") {
            sizeCode = "0x33"; // 4x4
          } else {
            sizeCode = "0x11"; // Default: 2x2
          }

          // Font tipi ayarÄ± (ESC M n)
          const fontCode = textOptions?.fontType === "B" ? "0x01" : "0x00"; // A=0, B=1

          // Hizalama ayarÄ±
          let alignCode = "0x00"; // Sol
          if (textOptions?.alignment === "center") {
            alignCode = "0x01";
          } else if (textOptions?.alignment === "right") {
            alignCode = "0x02";
          }

          // KalÄ±n yazÄ± ayarÄ±
          const boldOn = textOptions?.bold ? "0x01" : "0x00";
          
          // AltÄ± Ã§izili ayarÄ± (ESC - n)
          const underlineOn = textOptions?.underline ? "0x01" : "0x00";

          // SatÄ±r aralÄ±ÄŸÄ± (ESC 3 n) - 0-255 dot
          const lineSpacingValue = textOptions?.lineSpacing !== undefined ? `0x${textOptions.lineSpacing.toString(16).padStart(2, '0')}` : "0x1E"; // Default 30

          // Sol kenar boÅŸluÄŸu (GS L nL nH) - 0-65535 dot
          const leftMarginValue = textOptions?.leftMargin || 0;
          const leftMarginL = `0x${(leftMarginValue & 0xFF).toString(16).padStart(2, '0')}`;
          const leftMarginH = `0x${((leftMarginValue >> 8) & 0xFF).toString(16).padStart(2, '0')}`;

          // Ãœst boÅŸluk (satÄ±r sayÄ±sÄ±)
          const topSpacingValue = textOptions?.topSpacing || 2;

          textCommands = `
  # Metin yazdÄ±r
  # Ãœst boÅŸluk (ESC d n)
  $topSpaceBytes = [byte[]](0x1B, 0x64, ${topSpacingValue})
  $port.Write($topSpaceBytes, 0, $topSpaceBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Sol kenar boÅŸluÄŸu ayarla (GS L nL nH)
  $leftMarginBytes = [byte[]](0x1D, 0x4C, ${leftMarginL}, ${leftMarginH})
  $port.Write($leftMarginBytes, 0, $leftMarginBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # SatÄ±r aralÄ±ÄŸÄ± ayarla (ESC 3 n)
  $lineSpacingBytes = [byte[]](0x1B, 0x33, ${lineSpacingValue})
  $port.Write($lineSpacingBytes, 0, $lineSpacingBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Font tipi ayarla (ESC M n)
  $fontBytes = [byte[]](0x1B, 0x4D, ${fontCode})
  $port.Write($fontBytes, 0, $fontBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Hizalama ayarla (ESC a n)
  $alignBytes = [byte[]](0x1B, 0x61, ${alignCode})
  $port.Write($alignBytes, 0, $alignBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # KalÄ±n yazÄ± ayarla (ESC E n)
  $boldBytes = [byte[]](0x1B, 0x45, ${boldOn})
  $port.Write($boldBytes, 0, $boldBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # AltÄ± Ã§izili ayarla (ESC - n)
  $underlineBytes = [byte[]](0x1B, 0x2D, ${underlineOn})
  $port.Write($underlineBytes, 0, $underlineBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Metin boyutunu ayarla (GS ! n)
  $textSizeBytes = [byte[]](0x1D, 0x21, ${sizeCode})
  $port.Write($textSizeBytes, 0, $textSizeBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Metni yazdÄ±r
  $textBytes = [System.Text.Encoding]::GetEncoding(857).GetBytes("${escapedText}\n")
  $port.Write($textBytes, 0, $textBytes.Length)
  Start-Sleep -Milliseconds 100
  
  # AyarlarÄ± normale dÃ¶ndÃ¼r
  $normalSizeBytes = [byte[]](0x1D, 0x21, 0x00)  # Normal boyut
  $port.Write($normalSizeBytes, 0, $normalSizeBytes.Length)
  Start-Sleep -Milliseconds 50
  
  $normalBoldBytes = [byte[]](0x1B, 0x45, 0x00)  # KalÄ±n yazÄ± kapat
  $port.Write($normalBoldBytes, 0, $normalBoldBytes.Length)
  Start-Sleep -Milliseconds 50
  
  $normalUnderlineBytes = [byte[]](0x1B, 0x2D, 0x00)  # AltÄ± Ã§izili kapat
  $port.Write($normalUnderlineBytes, 0, $normalUnderlineBytes.Length)
  Start-Sleep -Milliseconds 50
  
  $normalAlignBytes = [byte[]](0x1B, 0x61, 0x00)  # Sol hizalama
  $port.Write($normalAlignBytes, 0, $normalAlignBytes.Length)
  Start-Sleep -Milliseconds 50
  
  $normalFontBytes = [byte[]](0x1B, 0x4D, 0x00)  # Font A
  $port.Write($normalFontBytes, 0, $normalFontBytes.Length)
  Start-Sleep -Milliseconds 50
  
  $normalLineSpacingBytes = [byte[]](0x1B, 0x32)  # ESC 2 - VarsayÄ±lan satÄ±r aralÄ±ÄŸÄ±
  $port.Write($normalLineSpacingBytes, 0, $normalLineSpacingBytes.Length)
  Start-Sleep -Milliseconds 50
  
  $resetMarginBytes = [byte[]](0x1D, 0x4C, 0x00, 0x00)  # Sol kenar sÄ±fÄ±rla
  $port.Write($resetMarginBytes, 0, $resetMarginBytes.Length)
  Start-Sleep -Milliseconds 50
`;
        }

        // Alt boÅŸluk deÄŸeri
        const bottomSpacingValue = textOptions?.bottomSpacing || 3;

        const psScript = `
$ErrorActionPreference = "Stop"

try {
    $port = New-Object System.IO.Ports.SerialPort("${portPath}", 9600, "None", 8, "One")
    $port.Handshake = [System.IO.Ports.Handshake]::RequestToSend
    $port.ReadTimeout = 1000
    $port.WriteTimeout = 1000
    
    $port.Open()
    
    if (-not $port.IsOpen) {
        Write-Error "Port aÃ§Ä±lamadÄ±"
        exit 1
    }
    
    # Initialize
    $initBytes = [byte[]](${escInit
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($initBytes, 0, $initBytes.Length)
    Start-Sleep -Milliseconds 50
    ${imageCommands}${textCommands}
    # Alt boÅŸluk (ESC d n)
    $bottomSpaceBytes = [byte[]](0x1B, 0x64, ${bottomSpacingValue})
    $port.Write($bottomSpaceBytes, 0, $bottomSpaceBytes.Length)
    Start-Sleep -Milliseconds 100
    
    # KaÄŸÄ±t ilerletme (fiÅŸi koparÄ±labilir hale getir)
    $feedBytes = [byte[]](0x1B, 0x64, 0x05)  # ESC d 5 - 5 satÄ±r boÅŸluk
    $port.Write($feedBytes, 0, $feedBytes.Length)
    Start-Sleep -Milliseconds 200
    
    # Cut paper (full cut)
    $cutBytes = [byte[]](${cutPaper
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($cutBytes, 0, $cutBytes.Length)
    Start-Sleep -Milliseconds 300
    
    # Ekstra feed (kesme sonrasÄ±)
    $finalFeedBytes = [byte[]](0x1B, 0x64, 0x03)  # ESC d 3 - 3 satÄ±r boÅŸluk
    $port.Write($finalFeedBytes, 0, $finalFeedBytes.Length)
    Start-Sleep -Milliseconds 200
    
    $port.Close()
    Write-Output "SUCCESS"
    exit 0
} catch {
    Write-Error $_.Exception.Message
    if ($port -and $port.IsOpen) {
        $port.Close()
    }
    exit 1
}
`;

        fs.writeFileSync(scriptPath, psScript, "utf8");

        const { stdout, stderr } = await execAsync(
          `powershell -ExecutionPolicy Bypass -File "${scriptPath}"`,
          { timeout: 10000 }
        );

        // Cleanup
        try {
          fs.unlinkSync(bitmapPath);
        } catch {}
        try {
          fs.unlinkSync(scriptPath);
        } catch {}

        if (stdout.includes("SUCCESS")) {
          console.log(`âœ… ${portPath} baÅŸarÄ±lÄ±!`);
          return {
            method: "Serial/USB",
            details: portPath,
            success: true,
          };
        }
      } catch (error: any) {
        console.log(`âŒ ${portPath} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }

    return {
      method: "Serial/USB",
      details: "HiÃ§bir port Ã§alÄ±ÅŸmadÄ±",
      success: false,
      error: "TÃ¼m portlar denendi, hiÃ§biri Ã§alÄ±ÅŸmadÄ±",
    };
  } catch (error: any) {
    return {
      method: "Serial/USB",
      details: "SerialPort yÃ¼klenemedi",
      success: false,
      error: error.message,
    };
  }
}

// Network baÄŸlantÄ±sÄ±nÄ± dene
async function tryNetwork(
  imageData: string | null,
  textData: string,
  textOptions?: {
    fontSize?: "small" | "normal" | "large" | "xlarge";
    fontType?: "A" | "B";
    alignment?: "left" | "center" | "right";
    bold?: boolean;
    underline?: boolean;
    lineSpacing?: number;
    leftMargin?: number;
    topSpacing?: number;
    bottomSpacing?: number;
  }
): Promise<PrintAttempt> {
  const ips = ["192.168.2.211", "192.168.1.100", "192.168.0.100"];
  const ports = [9100, 9101, 9102];

  for (const ip of ips) {
    for (const port of ports) {
      try {
        console.log(`ğŸŒ Network deneniyor: ${ip}:${port}`);

        const socket = new net.Socket();
        await new Promise<void>((resolve, reject) => {
          socket.setTimeout(2000);
          socket.on("connect", () => resolve());
          socket.on("timeout", () => reject(new Error("Timeout")));
          socket.on("error", (err) => reject(err));
          socket.connect(port, ip);
        });

        // BaÄŸlantÄ± baÅŸarÄ±lÄ±, yazdÄ±r
        const escInit = new Uint8Array([0x1b, 0x40]); // ESC @

        socket.write(escInit);

        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          // KP-302 iÃ§in optimize edilmiÅŸ gÃ¶rsel iÅŸleme
          const processedImage = await sharp(imageBuffer)
            .resize(576, null, {
              fit: "inside",
              withoutEnlargement: false,
              kernel: sharp.kernel.lanczos3, // Daha yumuÅŸak kenarlar
            })
            .grayscale()
            .normalise() // Kontrast normalleÅŸtirme
            .threshold(128, { greyscale: false }) // Binary threshold
            .toBuffer();

          // Sharp'Ä±n PNG Ã§Ä±ktÄ±sÄ±nÄ± yeniden okuyup raw'a Ã§evir
          const rawImage = await sharp(processedImage)
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = rawImage;
          const width = Math.min(info.width, 576);
          const height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          const bitmapBuffer = Buffer.alloc(bytesPerLine * height);
          bitmapBuffer.fill(0);

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = (y * info.width + x) * info.channels;
              const pixelValue = rawData[idx];

              // Sharp threshold: Siyah=0, Beyaz=255
              // Thermal printer: Bit 1=Siyah, Bit 0=Beyaz
              if (pixelValue < 128) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8); // MSB first
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }

          // Byte cinsinden geniÅŸlik hesabÄ±
          const widthBytes = Math.ceil(width / 8);
          const xL = widthBytes & 0xff;
          const xH = (widthBytes >> 8) & 0xff;
          const yL = height & 0xff;
          const yH = (height >> 8) & 0xff;

          console.log(
            `ğŸ“ Network bitmap: ${width}x${height}, ${widthBytes} bytes/satir, Data: ${bitmapBuffer.length} bytes`
          );

          const imageCommand = new Uint8Array([
            0x1d,
            0x76,
            0x30,
            0x00,
            xL,
            xH,
            yL,
            yH,
          ]);
          socket.write(imageCommand);
          socket.write(Uint8Array.from(bitmapBuffer));
        }

        if (textData && textData.trim().length > 0) {
          // Ãœst boÅŸluk (ESC d n)
          const topSpacingValue = textOptions?.topSpacing || 2;
          const feedBefore = new Uint8Array([0x1b, 0x64, topSpacingValue]);
          socket.write(feedBefore);

          // Sol kenar boÅŸluÄŸu (GS L nL nH)
          const leftMarginValue = textOptions?.leftMargin || 0;
          const leftMarginL = leftMarginValue & 0xFF;
          const leftMarginH = (leftMarginValue >> 8) & 0xFF;
          const leftMarginBytes = new Uint8Array([0x1d, 0x4c, leftMarginL, leftMarginH]);
          socket.write(leftMarginBytes);

          // SatÄ±r aralÄ±ÄŸÄ± (ESC 3 n)
          const lineSpacingValue = textOptions?.lineSpacing !== undefined ? textOptions.lineSpacing : 30;
          const lineSpacingBytes = new Uint8Array([0x1b, 0x33, lineSpacingValue]);
          socket.write(lineSpacingBytes);

          // Font tipi (ESC M n)
          const fontCode = textOptions?.fontType === "B" ? 0x01 : 0x00;
          const fontBytes = new Uint8Array([0x1b, 0x4d, fontCode]);
          socket.write(fontBytes);

          // Hizalama ayarÄ± (ESC a n)
          let alignCode = 0x00; // Sol
          if (textOptions?.alignment === "center") {
            alignCode = 0x01;
          } else if (textOptions?.alignment === "right") {
            alignCode = 0x02;
          }
          const alignBytes = new Uint8Array([0x1b, 0x61, alignCode]);
          socket.write(alignBytes);

          // KalÄ±n yazÄ± ayarÄ± (ESC E n)
          const boldCode = textOptions?.bold ? 0x01 : 0x00;
          const boldBytes = new Uint8Array([0x1b, 0x45, boldCode]);
          socket.write(boldBytes);

          // AltÄ± Ã§izili (ESC - n)
          const underlineCode = textOptions?.underline ? 0x01 : 0x00;
          const underlineBytes = new Uint8Array([0x1b, 0x2d, underlineCode]);
          socket.write(underlineBytes);

          // Metin boyutu (GS ! n)
          let sizeCode = 0x11; // Default: 2x2
          if (textOptions?.fontSize === "small") {
            sizeCode = 0x00; // 1x1
          } else if (textOptions?.fontSize === "normal") {
            sizeCode = 0x11; // 2x2
          } else if (textOptions?.fontSize === "large") {
            sizeCode = 0x22; // 3x3
          } else if (textOptions?.fontSize === "xlarge") {
            sizeCode = 0x33; // 4x4
          }
          const textSize = new Uint8Array([0x1d, 0x21, sizeCode]);
          socket.write(textSize);

          // Metin
          const textEncoder = new TextEncoder();
          socket.write(textEncoder.encode(textData + "\n"));

          // AyarlarÄ± normale dÃ¶ndÃ¼r
          const normalSize = new Uint8Array([0x1d, 0x21, 0x00]); // Normal boyut
          socket.write(normalSize);
          
          const normalBold = new Uint8Array([0x1b, 0x45, 0x00]); // KalÄ±n yazÄ± kapat
          socket.write(normalBold);
          
          const normalUnderline = new Uint8Array([0x1b, 0x2d, 0x00]); // AltÄ± Ã§izili kapat
          socket.write(normalUnderline);
          
          const normalAlign = new Uint8Array([0x1b, 0x61, 0x00]); // Sol hizalama
          socket.write(normalAlign);
          
          const normalFont = new Uint8Array([0x1b, 0x4d, 0x00]); // Font A
          socket.write(normalFont);
          
          const normalLineSpacing = new Uint8Array([0x1b, 0x32]); // VarsayÄ±lan satÄ±r aralÄ±ÄŸÄ±
          socket.write(normalLineSpacing);
          
          const resetMargin = new Uint8Array([0x1d, 0x4c, 0x00, 0x00]); // Sol kenar sÄ±fÄ±rla
          socket.write(resetMargin);

          // Alt boÅŸluk (ESC d n)
          const bottomSpacingValue = textOptions?.bottomSpacing || 3;
          const feedAfter = new Uint8Array([0x1b, 0x64, bottomSpacingValue]);
          socket.write(feedAfter);
        }

        // KaÄŸÄ±t ilerletme
        const feedPaper = new Uint8Array([0x1b, 0x64, 0x05]); // ESC d 5
        socket.write(feedPaper);

        const cutPaper = new Uint8Array([0x1d, 0x56, 0x00]); // GS V 0
        socket.write(cutPaper);

        // Ekstra feed
        const finalFeed = new Uint8Array([0x1b, 0x64, 0x03]); // ESC d 3
        socket.write(finalFeed);

        socket.end();

        console.log(`âœ… Network ${ip}:${port} baÅŸarÄ±lÄ±!`);
        return {
          method: "Network",
          details: `${ip}:${port}`,
          success: true,
        };
      } catch (error: any) {
        console.log(`âŒ Network ${ip}:${port} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }
  }

  return {
    method: "Network",
    details: "HiÃ§bir network adresi Ã§alÄ±ÅŸmadÄ±",
    success: false,
    error: "TÃ¼m network adresleri denendi",
  };
}

// ==========================================
// API ENDPOINT - Auto Print Handler
// ==========================================
export async function POST(request: NextRequest) {
  try {
    const { imageData, textData, textOptions } = await request.json();

    console.log("========================================");
    console.log("ğŸ¤– OTOMATÄ°K YAZDIRMA - KP-302 YazÄ±cÄ±");
    console.log("GÃ¶rsel:", !!imageData);
    console.log("Metin:", !!textData);
    if (textOptions) {
      console.log("Metin FormatÄ±:", {
        fontSize: textOptions.fontSize || "normal",
        fontType: textOptions.fontType || "A",
        alignment: textOptions.alignment || "left",
        bold: textOptions.bold || false,
        underline: textOptions.underline || false,
        lineSpacing: textOptions.lineSpacing || 30,
        leftMargin: textOptions.leftMargin || 0,
        topSpacing: textOptions.topSpacing || 2,
        bottomSpacing: textOptions.bottomSpacing || 3,
      });
    }
    console.log("Ã–ncelik: 1) COM Port  2) Ethernet");
    console.log("========================================");

    const attempts: PrintAttempt[] = [];

    // ==========================================
    // Ã–NCELÄ°K 1: COM PORT (Serial) - TEK YÃ–NTEM
    // KP-302 iÃ§in Ã¶ncelikli baÄŸlantÄ± yÃ¶ntemi
    // ==========================================
    console.log("\nğŸ”Œ Ã–NCELÄ°K 1: COM PORT BAÄLANTISI");
    console.log("ğŸ“‹ KP-302: Serial/COM interface (Ã¶ncelikli)");
    console.log("========================================");

    const serialResult = await trySerialPorts(imageData, textData, textOptions);
    attempts.push(serialResult);
    if (serialResult.success) {
      console.log("âœ… COM PORT BAÄLANTISI BAÅARILI!");
      console.log(`   Port: ${serialResult.details}`);
      return NextResponse.json({
        success: true,
        message: `âœ… COM Port Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${serialResult.details}`,
        method: serialResult.method,
        details: serialResult.details,
        connectionType: "COM Port",
        priority: 1,
        attempts,
      });
    }

    console.log("\nâŒ COM PORT MÃœSAÄ°T DEÄÄ°L");
    console.log("   HiÃ§bir COM portu bulunamadÄ± veya Ã§alÄ±ÅŸmadÄ±");

    // ==========================================
    // Ã–NCELÄ°K 2: ETHERNET BAÄLANTISI
    // COM port mÃ¼sait deÄŸilse alternatif baÄŸlantÄ±
    // ==========================================
    console.log("\nğŸŒ Ã–NCELÄ°K 2: ETHERNET BAÄLANTISI");
    console.log("ğŸ“‹ KP-302: Network interface (alternatif)");
    console.log("========================================");

    const networkResult = await tryNetwork(imageData, textData, textOptions);
    attempts.push(networkResult);
    if (networkResult.success) {
      console.log("âœ… ETHERNET BAÄLANTISI BAÅARILI!");
      console.log(`   Adres: ${networkResult.details}`);
      return NextResponse.json({
        success: true,
        message: `âœ… Ethernet Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${networkResult.details}`,
        method: networkResult.method,
        details: networkResult.details,
        connectionType: "Ethernet",
        priority: 2,
        attempts,
      });
    }

    console.log("\nâŒ ETHERNET BAÄLANTISI MÃœSAÄ°T DEÄÄ°L");

    // ==========================================
    // YAZDIRMA BAÅARISIZ
    // ==========================================
    console.log("\n========================================");
    console.log("âŒ YAZDIRMA BAÅARISIZ");
    console.log("   Ne COM Port ne de Ethernet mÃ¼sait");
    console.log("========================================");
    console.log("\nDenenen YÃ¶ntemler:");
    attempts.forEach((attempt, index) => {
      const status = attempt.success ? "âœ…" : "âŒ";
      console.log(`  ${index + 1}. ${status} ${attempt.method}`);
      console.log(`     ${attempt.details}`);
      if (attempt.error) console.log(`     Hata: ${attempt.error}`);
    });
    console.log("\n========================================");
    console.log("ğŸ’¡ SORUN GÄ°DERME:");
    console.log("========================================");
    console.log("ğŸ“Œ COM Port BaÄŸlantÄ±sÄ± iÃ§in:");
    console.log("   âœ“ KP-302'nin USB kablosunun takÄ±lÄ± olduÄŸunu kontrol edin");
    console.log(
      "   âœ“ Cihaz YÃ¶neticisi'nde COM portunu bulun (Ã¶rn: COM3, COM4)"
    );
    console.log("   âœ“ YazÄ±cÄ± sÃ¼rÃ¼cÃ¼lerinin yÃ¼klÃ¼ olduÄŸunu doÄŸrulayÄ±n");
    console.log("   âœ“ BaÅŸka program portu kullanÄ±yor olabilir - kapatÄ±n");
    console.log("\nğŸ“Œ Ethernet BaÄŸlantÄ±sÄ± iÃ§in:");
    console.log("   âœ“ Network kablosunun baÄŸlÄ± olduÄŸunu kontrol edin");
    console.log(
      "   âœ“ YazÄ±cÄ±nÄ±n IP adresini doÄŸrulayÄ±n (varsayÄ±lan: 192.168.2.211)"
    );
    console.log("   âœ“ Firewall'un 9100 portunu engellememesini saÄŸlayÄ±n");
    console.log("   âœ“ YazÄ±cÄ± ve bilgisayar aynÄ± network'te olmalÄ±");

    return NextResponse.json({
      success: false,
      error: "YazÄ±cÄ± bulunamadÄ± - COM Port ve Ethernet baÄŸlantÄ±sÄ± mÃ¼sait deÄŸil",
      attempts,
      troubleshooting: {
        comPort:
          "USB kablosu takÄ±lÄ± mÄ±? Cihaz YÃ¶neticisi'nde COM portu gÃ¶rÃ¼nÃ¼yor mu? (COM3 gibi)",
        ethernet:
          "Network kablosu baÄŸlÄ± mÄ±? IP adresi doÄŸru mu? (192.168.2.211)",
      },
    });
  } catch (error: any) {
    console.error("========================================");
    console.error("âŒ YAZDIRMA HATASI");
    console.error("Hata:", error.message);
    console.error("Stack:", error.stack);
    console.error("========================================");

    return NextResponse.json({
      success: false,
      error: error.message || "Bilinmeyen hata",
    });
  }
}
