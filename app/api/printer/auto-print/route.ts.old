import { NextRequest, NextResponse } from "next/server";
import * as net from "net";
import sharp from "sharp";

// ESCPOS kÃ¼tÃ¼phanesi - Standart ve gÃ¼venilir
let EscPos: any = null;
let SerialPort: any = null;

async function loadEscPos() {
  if (!EscPos) {
    const escposModule = await import("escpos");
    EscPos = escposModule.default;
    // @ts-ignore
    EscPos.USB = await import("escpos-usb");
    // @ts-ignore  
    EscPos.Serial = await import("escpos-serialport");
  }
  return EscPos;
}

async function loadSerialPort() {
  if (!SerialPort) {
    const serialModule = await import("serialport");
    SerialPort = serialModule.SerialPort;
  }
  return SerialPort;
}

interface PrintAttempt {
  method: string;
  details: string;
  success: boolean;
  error?: string;
}

// ==========================================
// COM PORT - Serial Communication (Priority 1)
// ==========================================
async function trySerialPorts(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  try {
    const { SerialPort } = await import("serialport");
    const ports = await SerialPort.list();

    console.log(`ğŸ” ${ports.length} serial port bulundu`);

    // Her portu dene
    for (const portInfo of ports) {
      const portPath = portInfo.path;
      console.log(`ğŸ”Œ Port deneniyor: ${portPath}`);

      try {
        // GÃ¶rsel iÅŸleme - KP-301H iÃ§in optimize edilmiÅŸ
        let bitmapBuffer: Buffer | null = null;
        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          // KP-301H: 576 dots geniÅŸlik (72mm x 8 dots/mm), 203 DPI
          // Floyd-Steinberg dithering ile Ã§ok daha iyi sonuÃ§
          const processedImage = await sharp(imageBuffer)
            .resize(576, null, {
              fit: "inside",
              withoutEnlargement: false,
              kernel: sharp.kernel.lanczos3, // Daha kaliteli resize
            })
            .grayscale()
            .normalise() // Kontrast artÄ±r
            .png() // PNG olarak kaydet (dithering iÃ§in)
            .toBuffer();

          // Raw formata Ã§evir - Floyd-Steinberg dithering ile
          const rawImage = await sharp(processedImage)
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = rawImage;
          const width = Math.min(info.width, 576); // Maksimum 576
          const height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          bitmapBuffer = Buffer.alloc(bytesPerLine * height);
          bitmapBuffer.fill(0); // Temiz baÅŸlangÄ±Ã§

          // Floyd-Steinberg Dithering algoritmasÄ±
          // Termal yazÄ±cÄ±lar iÃ§in kritik - detaylarÄ± korur
          const errorBuffer = new Float32Array(width * height);

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = y * info.width + x;
              let pixelValue =
                rawData[idx * info.channels] + (errorBuffer[idx] || 0);

              // Threshold ile siyah/beyaz karar
              const newPixel = pixelValue < 128 ? 0 : 255;
              const error = pixelValue - newPixel;

              // HatayÄ± komÅŸu piksellere daÄŸÄ±t (Floyd-Steinberg)
              if (x + 1 < width) errorBuffer[y * width + x + 1] += error * (7 / 16);
              if (y + 1 < height) {
                if (x > 0) errorBuffer[(y + 1) * width + x - 1] += error * (3 / 16);
                errorBuffer[(y + 1) * width + x] += error * (5 / 16);
                if (x + 1 < width) errorBuffer[(y + 1) * width + x + 1] += error * (1 / 16);
              }

              // Siyah piksel ise bit set et
              if (newPixel === 0) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8);
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }
        }

        // PowerShell script oluÅŸtur
        const bitmapPath = path.join(
          os.tmpdir(),
          `thermal-auto-${Date.now()}.bin`
        );
        const scriptPath = path.join(
          os.tmpdir(),
          `thermal-auto-${Date.now()}.ps1`
        );

        let imageWidth = 0;
        let imageHeight = 0;

        if (bitmapBuffer) {
          // Bitmap boyutlarÄ±nÄ± hesapla
          const bytesPerLine = Math.ceil(576 / 8); // 72 byte per line
          imageWidth = 576;
          imageHeight = Math.floor(bitmapBuffer.length / bytesPerLine);

          console.log(
            `ğŸ“ Bitmap boyutu: ${imageWidth}x${imageHeight}, Data: ${bitmapBuffer.length} bytes`
          );
          fs.writeFileSync(bitmapPath, Uint8Array.from(bitmapBuffer));
        }

        const escInit = "1B 40"; // ESC @
        const feedPaper = "1B 64 03"; // ESC d 3 - 3 satÄ±r feed
        const cutPaper = "1D 56 42 00"; // GS V 66 0 - Full cut with feed (KP-301H)

        let imageCommands = "";
        if (bitmapBuffer && imageWidth > 0 && imageHeight > 0) {
          const xL = imageWidth & 0xff;
          const xH = (imageWidth >> 8) & 0xff;
          const yL = imageHeight & 0xff;
          const yH = (imageHeight >> 8) & 0xff;

          imageCommands = `
  # GÃ¶rsel yazdÄ±r - GS v 0 komutu
  Write-Host "Gorsel yazdiriliyor: ${imageWidth}x${imageHeight}"
  $imageCommand = [byte[]](0x1D, 0x76, 0x30, 0x00, ${xL}, ${xH}, ${yL}, ${yH})
  $port.Write($imageCommand, 0, $imageCommand.Length)
  Start-Sleep -Milliseconds 100
  
  $bitmapData = [System.IO.File]::ReadAllBytes("${bitmapPath.replace(
    /\\/g,
    "\\\\"
  )}")
  Write-Host "Bitmap data boyutu:" $bitmapData.Length
  $port.Write($bitmapData, 0, $bitmapData.Length)
  Start-Sleep -Milliseconds 200
`;
        }

        let textCommands = "";
        if (textData && textData.trim().length > 0) {
          const escapedText = textData
            .replace(/"/g, '`"')
            .replace(/\$/g, "`$")
            .replace(/\r/g, "");
          textCommands = `
  # Metin yazdÄ±r
  # SatÄ±r baÅŸÄ±
  $feedBytes = [byte[]](0x1B, 0x64, 0x02)  # ESC d 2 - 2 satÄ±r boÅŸluk
  $port.Write($feedBytes, 0, $feedBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Metin boyutunu bÃ¼yÃ¼t (2x geniÅŸlik, 2x yÃ¼kseklik)
  $textSizeBytes = [byte[]](0x1D, 0x21, 0x11)  # GS ! 17 (0x11)
  $port.Write($textSizeBytes, 0, $textSizeBytes.Length)
  Start-Sleep -Milliseconds 50
  
  # Metni yazdÄ±r
  $textBytes = [System.Text.Encoding]::GetEncoding(857).GetBytes("${escapedText}\n")
  $port.Write($textBytes, 0, $textBytes.Length)
  Start-Sleep -Milliseconds 100
  
  # Metin boyutunu normale al
  $normalSizeBytes = [byte[]](0x1D, 0x21, 0x00)  # GS ! 0
  $port.Write($normalSizeBytes, 0, $normalSizeBytes.Length)
  Start-Sleep -Milliseconds 50
`;
        }

        const psScript = `
$ErrorActionPreference = "Stop"

try {
    $port = New-Object System.IO.Ports.SerialPort("${portPath}", 9600, "None", 8, "One")
    $port.Handshake = [System.IO.Ports.Handshake]::RequestToSend
    $port.ReadTimeout = 1000
    $port.WriteTimeout = 1000
    
    $port.Open()
    
    if (-not $port.IsOpen) {
        Write-Error "Port aÃ§Ä±lamadÄ±"
        exit 1
    }
    
    # Initialize
    $initBytes = [byte[]](${escInit
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($initBytes, 0, $initBytes.Length)
    Start-Sleep -Milliseconds 50
    ${imageCommands}${textCommands}
    # KaÄŸÄ±t ilerletme (fiÅŸi koparÄ±labilir hale getir)
    $feedBytes = [byte[]](${feedPaper
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($feedBytes, 0, $feedBytes.Length)
    Start-Sleep -Milliseconds 200
    
    # Cut paper (full cut with feed - KP-301H)
    $cutBytes = [byte[]](${cutPaper
      .split(" ")
      .map((b) => `0x${b}`)
      .join(", ")})
    $port.Write($cutBytes, 0, $cutBytes.Length)
    Start-Sleep -Milliseconds 500
    
    # Ekstra feed (kesme sonrasÄ± - emin olmak iÃ§in)
    $extraFeedBytes = [byte[]](0x1B, 0x64, 0x05)  # ESC d 5 - 5 satÄ±r boÅŸluk
    $port.Write($extraFeedBytes, 0, $extraFeedBytes.Length)
    Start-Sleep -Milliseconds 300
    
    $port.Close()
    Write-Output "SUCCESS"
    exit 0
} catch {
    Write-Error $_.Exception.Message
    if ($port -and $port.IsOpen) {
        $port.Close()
    }
    exit 1
}
`;

        fs.writeFileSync(scriptPath, psScript, "utf8");

        const { stdout, stderr } = await execAsync(
          `powershell -ExecutionPolicy Bypass -File "${scriptPath}"`,
          { timeout: 10000 }
        );

        // Cleanup
        try {
          fs.unlinkSync(bitmapPath);
        } catch {}
        try {
          fs.unlinkSync(scriptPath);
        } catch {}

        if (stdout.includes("SUCCESS")) {
          console.log(`âœ… ${portPath} baÅŸarÄ±lÄ±!`);
          return {
            method: "Serial/USB",
            details: portPath,
            success: true,
          };
        }
      } catch (error: any) {
        console.log(`âŒ ${portPath} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }

    return {
      method: "Serial/USB",
      details: "HiÃ§bir port Ã§alÄ±ÅŸmadÄ±",
      success: false,
      error: "TÃ¼m portlar denendi, hiÃ§biri Ã§alÄ±ÅŸmadÄ±",
    };
  } catch (error: any) {
    return {
      method: "Serial/USB",
      details: "SerialPort yÃ¼klenemedi",
      success: false,
      error: error.message,
    };
  }
}

// Network baÄŸlantÄ±sÄ±nÄ± dene
async function tryNetwork(
  imageData: string | null,
  textData: string
): Promise<PrintAttempt> {
  const ips = ["192.168.2.211", "192.168.1.100", "192.168.0.100"];
  const ports = [9100, 9101, 9102];

  for (const ip of ips) {
    for (const port of ports) {
      try {
        console.log(`ğŸŒ Network deneniyor: ${ip}:${port}`);

        const socket = new net.Socket();
        await new Promise<void>((resolve, reject) => {
          socket.setTimeout(2000);
          socket.on("connect", () => resolve());
          socket.on("timeout", () => reject(new Error("Timeout")));
          socket.on("error", (err) => reject(err));
          socket.connect(port, ip);
        });

        // BaÄŸlantÄ± baÅŸarÄ±lÄ±, yazdÄ±r
        const escInit = new Uint8Array([0x1b, 0x40]); // ESC @

        socket.write(escInit);

        if (imageData) {
          const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
          const imageBuffer = Buffer.from(base64Data, "base64");

          // KP-301H iÃ§in optimize edilmiÅŸ gÃ¶rsel iÅŸleme
          const processedImage = await sharp(imageBuffer)
            .resize(576, null, {
              fit: "inside",
              withoutEnlargement: false,
              kernel: sharp.kernel.lanczos3, // Daha kaliteli resize
            })
            .grayscale()
            .normalise() // Kontrast artÄ±r
            .png()
            .toBuffer();

          // Raw formata Ã§evir - Floyd-Steinberg dithering ile
          const rawImage = await sharp(processedImage)
            .raw()
            .toBuffer({ resolveWithObject: true });

          const { data: rawData, info } = rawImage;
          const width = Math.min(info.width, 576);
          const height = info.height;
          const bytesPerLine = Math.ceil(width / 8);

          const bitmapBuffer = Buffer.alloc(bytesPerLine * height);
          bitmapBuffer.fill(0);

          // Floyd-Steinberg Dithering - termal yazÄ±cÄ± iÃ§in en iyi
          const errorBuffer = new Float32Array(width * height);

          for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
              const idx = y * info.width + x;
              let pixelValue =
                rawData[idx * info.channels] + (errorBuffer[idx] || 0);

              const newPixel = pixelValue < 128 ? 0 : 255;
              const error = pixelValue - newPixel;

              // HatayÄ± komÅŸu piksellere daÄŸÄ±t
              if (x + 1 < width) errorBuffer[y * width + x + 1] += error * (7 / 16);
              if (y + 1 < height) {
                if (x > 0) errorBuffer[(y + 1) * width + x - 1] += error * (3 / 16);
                errorBuffer[(y + 1) * width + x] += error * (5 / 16);
                if (x + 1 < width) errorBuffer[(y + 1) * width + x + 1] += error * (1 / 16);
              }

              if (newPixel === 0) {
                const byteIndex = y * bytesPerLine + Math.floor(x / 8);
                const bitIndex = 7 - (x % 8);
                bitmapBuffer[byteIndex] |= 1 << bitIndex;
              }
            }
          }

          const xL = width & 0xff;
          const xH = (width >> 8) & 0xff;
          const yL = height & 0xff;
          const yH = (height >> 8) & 0xff;

          console.log(
            `ğŸ“ Network bitmap: ${width}x${height}, Data: ${bitmapBuffer.length} bytes`
          );

          const imageCommand = new Uint8Array([
            0x1d,
            0x76,
            0x30,
            0x00,
            xL,
            xH,
            yL,
            yH,
          ]);
          socket.write(imageCommand);
          socket.write(Uint8Array.from(bitmapBuffer));
        }

        if (textData && textData.trim().length > 0) {
          // SatÄ±r boÅŸluÄŸu
          const feedBefore = new Uint8Array([0x1b, 0x64, 0x02]); // ESC d 2
          socket.write(feedBefore);

          // Metin boyutu (2x)
          const textSize = new Uint8Array([0x1d, 0x21, 0x11]); // GS ! 17
          socket.write(textSize);

          // Metin
          const textEncoder = new TextEncoder();
          socket.write(textEncoder.encode(textData + "\n"));

          // Boyut normale dÃ¶n
          const normalSize = new Uint8Array([0x1d, 0x21, 0x00]); // GS ! 0
          socket.write(normalSize);
        }

        // KaÄŸÄ±t ilerlet
        const feedPaper = new Uint8Array([0x1b, 0x64, 0x03]); // ESC d 3
        socket.write(feedPaper);

        // GS V 66 0 - Full cut with feed (KP-301H iÃ§in)
        const cutPaper = new Uint8Array([0x1d, 0x56, 0x42, 0x00]); // GS V 66 0
        socket.write(cutPaper);

        // Ekstra feed (kesme sonrasÄ±)
        const extraFeed = new Uint8Array([0x1b, 0x64, 0x05]); // ESC d 5
        socket.write(extraFeed);

        socket.end();

        console.log(`âœ… Network ${ip}:${port} baÅŸarÄ±lÄ±!`);
        return {
          method: "Network",
          details: `${ip}:${port}`,
          success: true,
        };
      } catch (error: any) {
        console.log(`âŒ Network ${ip}:${port} baÅŸarÄ±sÄ±z: ${error.message}`);
        continue;
      }
    }
  }

  return {
    method: "Network",
    details: "HiÃ§bir network adresi Ã§alÄ±ÅŸmadÄ±",
    success: false,
    error: "TÃ¼m network adresleri denendi",
  };
}

// ==========================================
// API ENDPOINT - Auto Print Handler
// ==========================================
export async function POST(request: NextRequest) {
  try {
    const { imageData, textData } = await request.json();

    console.log("========================================");
    console.log("ğŸ¤– OTOMATÄ°K YAZDIRMA - KP-301H YazÄ±cÄ±");
    console.log("GÃ¶rsel:", !!imageData);
    console.log("Metin:", !!textData);
    console.log("Ã–ncelik: 1) COM Port  2) Ethernet");
    console.log("========================================");

    const attempts: PrintAttempt[] = [];

    // ==========================================
    // Ã–NCELÄ°K 1: COM PORT (Serial) - TEK YÃ–NTEM
    // KP-302 iÃ§in Ã¶ncelikli baÄŸlantÄ± yÃ¶ntemi
    // ==========================================
    console.log("\nğŸ”Œ Ã–NCELÄ°K 1: COM PORT BAÄLANTISI");
    console.log("ğŸ“‹ KP-301H: Serial/COM interface (Ã¶ncelikli)");
    console.log("========================================");

    const serialResult = await trySerialPorts(imageData, textData);
    attempts.push(serialResult);
    if (serialResult.success) {
      console.log("âœ… COM PORT BAÄLANTISI BAÅARILI!");
      console.log(`   Port: ${serialResult.details}`);
      return NextResponse.json({
        success: true,
        message: `âœ… COM Port Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${serialResult.details}`,
        method: serialResult.method,
        details: serialResult.details,
        connectionType: "COM Port",
        priority: 1,
        attempts,
      });
    }

    console.log("\nâŒ COM PORT MÃœSAÄ°T DEÄÄ°L");
    console.log("   HiÃ§bir COM portu bulunamadÄ± veya Ã§alÄ±ÅŸmadÄ±");

    // ==========================================
    // Ã–NCELÄ°K 2: ETHERNET BAÄLANTISI
    // COM port mÃ¼sait deÄŸilse alternatif baÄŸlantÄ±
    // ==========================================
    console.log("\nğŸŒ Ã–NCELÄ°K 2: ETHERNET BAÄLANTISI");
    console.log("ğŸ“‹ KP-301H: Network interface (alternatif)");
    console.log("========================================");

    const networkResult = await tryNetwork(imageData, textData);
    attempts.push(networkResult);
    if (networkResult.success) {
      console.log("âœ… ETHERNET BAÄLANTISI BAÅARILI!");
      console.log(`   Adres: ${networkResult.details}`);
      return NextResponse.json({
        success: true,
        message: `âœ… Ethernet Ã¼zerinden yazdÄ±rÄ±ldÄ±: ${networkResult.details}`,
        method: networkResult.method,
        details: networkResult.details,
        connectionType: "Ethernet",
        priority: 2,
        attempts,
      });
    }

    console.log("\nâŒ ETHERNET BAÄLANTISI MÃœSAÄ°T DEÄÄ°L");

    // ==========================================
    // YAZDIRMA BAÅARISIZ
    // ==========================================
    console.log("\n========================================");
    console.log("âŒ YAZDIRMA BAÅARISIZ");
    console.log("   Ne COM Port ne de Ethernet mÃ¼sait");
    console.log("========================================");
    console.log("\nDenenen YÃ¶ntemler:");
    attempts.forEach((attempt, index) => {
      const status = attempt.success ? "âœ…" : "âŒ";
      console.log(`  ${index + 1}. ${status} ${attempt.method}`);
      console.log(`     ${attempt.details}`);
      if (attempt.error) console.log(`     Hata: ${attempt.error}`);
    });
    console.log("\n========================================");
    console.log("ğŸ’¡ SORUN GÄ°DERME:");
    console.log("========================================");
    console.log("ğŸ“Œ COM Port BaÄŸlantÄ±sÄ± iÃ§in:");
    console.log("   âœ“ KP-301H'nin USB kablosunun takÄ±lÄ± olduÄŸunu kontrol edin");
    console.log(
      "   âœ“ Cihaz YÃ¶neticisi'nde COM portunu bulun (Ã¶rn: COM3, COM4)"
    );
    console.log("   âœ“ YazÄ±cÄ± sÃ¼rÃ¼cÃ¼lerinin yÃ¼klÃ¼ olduÄŸunu doÄŸrulayÄ±n");
    console.log("   âœ“ BaÅŸka program portu kullanÄ±yor olabilir - kapatÄ±n");
    console.log("\nğŸ“Œ Ethernet BaÄŸlantÄ±sÄ± iÃ§in:");
    console.log("   âœ“ Network kablosunun baÄŸlÄ± olduÄŸunu kontrol edin");
    console.log(
      "   âœ“ YazÄ±cÄ±nÄ±n IP adresini doÄŸrulayÄ±n (varsayÄ±lan: 192.168.2.211)"
    );
    console.log("   âœ“ Firewall'un 9100 portunu engellememesini saÄŸlayÄ±n");
    console.log("   âœ“ YazÄ±cÄ± ve bilgisayar aynÄ± network'te olmalÄ±");

    return NextResponse.json({
      success: false,
      error: "YazÄ±cÄ± bulunamadÄ± - COM Port ve Ethernet baÄŸlantÄ±sÄ± mÃ¼sait deÄŸil",
      attempts,
      troubleshooting: {
        comPort:
          "USB kablosu takÄ±lÄ± mÄ±? Cihaz YÃ¶neticisi'nde COM portu gÃ¶rÃ¼nÃ¼yor mu? (COM3 gibi)",
        ethernet:
          "Network kablosu baÄŸlÄ± mÄ±? IP adresi doÄŸru mu? (192.168.2.211)",
      },
    });
  } catch (error: any) {
    console.error("========================================");
    console.error("âŒ YAZDIRMA HATASI");
    console.error("Hata:", error.message);
    console.error("Stack:", error.stack);
    console.error("========================================");

    return NextResponse.json({
      success: false,
      error: error.message || "Bilinmeyen hata",
    });
  }
}
