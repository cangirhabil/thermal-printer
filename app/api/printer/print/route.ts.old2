import { NextRequest, NextResponse } from "next/server";
import { ApiResponse, PrintRequest } from "@/types/printer";

// API Route yapılandırması
export const runtime = "nodejs";
export const maxDuration = 30;
export const dynamic = "force-dynamic";
import os from "os";

// Dinamik import fonksiyonları
async function getThermalPrinter() {
  try {
    const { ThermalPrinter, PrinterTypes } = await import(
      "node-thermal-printer"
    );
    return { ThermalPrinter, PrinterTypes };
  } catch (error) {
    console.error("ThermalPrinter yüklenemedi:", error);
    return null;
  }
}

async function getSharp() {
  try {
    const sharp = (await import("sharp")).default;
    return sharp;
  } catch (error) {
    console.error("Sharp yüklenemedi:", error);
    return null;
  }
}

export async function POST(request: NextRequest) {
  try {
    const body: PrintRequest = await request.json();
    const { imageData, settings } = body;

    // Kütüphaneleri yükle
    const printerLib = await getThermalPrinter();
    const sharp = await getSharp();

    if (!printerLib) {
      return NextResponse.json<ApiResponse>({
        success: false,
        error: "Yazıcı kütüphanesi yüklenemedi. npm install çalıştırın.",
      });
    }

    if (!sharp) {
      return NextResponse.json<ApiResponse>({
        success: false,
        error: "Görsel işleme kütüphanesi yüklenemedi.",
      });
    }

    const { ThermalPrinter, PrinterTypes } = printerLib;

    // KP-301H Yazıcı yapılandırması
    // KP-301H: 80mm termal yazıcı, ESC/POS protokolü
    // Paper width: 80mm ±0.5mm
    // Printing width: 72mm (576 dots)
    // Resolution: 203 DPI (8 dots/mm)
    let printerConfig: any = {
      type: PrinterTypes.EPSON, // KP-301H ESC/POS uyumlu
      interface: "",
      width: 48, // 80mm = 576 dots ÷ 12 = 48 karakter/satır
      characterSet: "PC857_TURKISH", // Türkçe karakter desteği (Code Page 857)
      removeSpecialCharacters: false,
      lineCharacter: "=",
      breakLine: true,
      options: {
        timeout: 10000,
      },
    };

    // Bağlantı tipine göre yapılandırma
    switch (settings.connectionType) {
      case "serial":
      case "usb":
        if (!settings.serialPort) {
          return NextResponse.json<ApiResponse>({
            success: false,
            error: "Serial/USB port seçilmedi",
          });
        }
        printerConfig.interface = formatInterface(settings.serialPort);
        printerConfig.options = {
          baudRate: 9600,
          dataBits: 8,
          stopBits: 1,
          parity: "none",
          rtscts: true, // Hardware Flow Control AKTIF
          xon: false,
          xoff: false,
          xany: false,
        };
        break;

      case "network":
        if (!settings.networkIp) {
          return NextResponse.json<ApiResponse>({
            success: false,
            error: "IP adresi girilmedi",
          });
        }
        printerConfig.interface = `tcp://${settings.networkIp}:${
          settings.networkPort || 9100
        }`;
        printerConfig.options = {
          timeout: 10000, // 10 saniye timeout
        };
        break;

      case "windows-printer":
        if (!settings.windowsPrinterName) {
          return NextResponse.json<ApiResponse>({
            success: false,
            error: "Windows yazıcı adı girilmedi",
          });
        }
        printerConfig.interface = `printer:${settings.windowsPrinterName}`;
        break;

      default:
        return NextResponse.json<ApiResponse>({
          success: false,
          error: "Geçersiz bağlantı tipi",
        });
    }

    // Yazıcı örneği oluştur
    const printer = new ThermalPrinter(printerConfig);

    // Base64 görselini buffer'a çevir
    const base64Data = imageData.replace(/^data:image\/\w+;base64,/, "");
    const imageBuffer = Buffer.from(base64Data, "base64");

    // KP-301H için görsel işleme
    // Çözünürlük: 203 DPI (8 dots/mm)
    // Yazdırma genişliği: 72mm = 576 dots
    // Floyd-Steinberg dithering ile optimum kalite
    console.log("Görsel işleniyor...");
    
    // İlk işleme: resize ve grayscale
    const resizedImage = await sharp(imageBuffer)
      .resize(576, null, {
        fit: "inside",
        withoutEnlargement: true,
        kernel: sharp.kernel.lanczos3,
      })
      .grayscale()
      .normalise()
      .raw()
      .toBuffer({ resolveWithObject: true });

    const { data: rawData, info } = resizedImage;
    const width = info.width;
    const height = info.height;
    
    console.log(`✓ Görsel yeniden boyutlandırıldı: ${width}x${height}`);

    // Floyd-Steinberg Dithering
    const dithered = new Uint8Array(width * height);
    const errors = new Float32Array(width * height);

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const idx = y * width + x;
        let oldPixel = rawData[idx] + (errors[idx] || 0);
        const newPixel = oldPixel < 128 ? 0 : 255;
        dithered[idx] = newPixel;
        const error = oldPixel - newPixel;

        // Hatayı dağıt
        if (x + 1 < width) errors[idx + 1] += (error * 7) / 16;
        if (y + 1 < height) {
          if (x > 0) errors[idx + width - 1] += (error * 3) / 16;
          errors[idx + width] += (error * 5) / 16;
          if (x + 1 < width) errors[idx + width + 1] += (error * 1) / 16;
        }
      }
    }

    console.log("✓ Floyd-Steinberg dithering uygulandı");

    // Bitmap'e çevir (GS v 0 için)
    const bytesPerLine = Math.ceil(width / 8);
    const bitmapData = Buffer.alloc(bytesPerLine * height);

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        if (dithered[y * width + x] === 0) {
          // Siyah piksel
          const byteIndex = y * bytesPerLine + Math.floor(x / 8);
          const bitIndex = 7 - (x % 8);
          bitmapData[byteIndex] |= 1 << bitIndex;
        }
      }
    }

    console.log(`✓ Bitmap oluşturuldu: ${bitmapData.length} bytes`);

    // Yazdırma işlemi
    try {
      console.log("========================================");
      console.log("YAZDIRMA İŞLEMİ BAŞLADI");
      console.log("========================================");
      console.log("Yazıcı tipi:", printerConfig.type);
      console.log("Bağlantı interface:", printerConfig.interface);
      console.log("Bağlantı tipi:", settings.connectionType);
      console.log("Görsel boyutu:", width, "x", height);
      console.log("Bitmap boyutu:", bitmapData.length, "bytes");
      console.log("----------------------------------------");

      // ESC @ - Initialize
      printer.raw(Buffer.from([0x1b, 0x40]));
      console.log("✓ Yazıcı initialize edildi");

      // ESC a 1 - Center align
      printer.raw(Buffer.from([0x1b, 0x61, 0x01]));
      console.log("✓ Ortalama ayarlandı");

      // GS v 0 - Print raster bitmap
      const xL = bytesPerLine & 0xff;
      const xH = (bytesPerLine >> 8) & 0xff;
      const yL = height & 0xff;
      const yH = (height >> 8) & 0xff;

      const imageCommand = Buffer.from([0x1d, 0x76, 0x30, 0x00, xL, xH, yL, yH]);
      printer.raw(imageCommand);
      printer.raw(bitmapData);
      console.log("✓ Görsel komutu yazıldı");

      // Kağıt ilerlet
      printer.raw(Buffer.from([0x1b, 0x64, 0x03])); // ESC d 3 - 3 satır feed
      console.log("✓ Kağıt ilerletme eklendi");

      // GS V 66 - Full cut + feed (KP-301H için en iyi)
      printer.raw(Buffer.from([0x1d, 0x56, 0x42, 0x00])); // GS V 66 0
      console.log("✓ Kesme komutu eklendi (Full Cut)");

      console.log("Yazıcıya gönderiliyor...");
      await printer.execute();
      console.log("✓ Komutlar yazıcıya gönderildi");

      console.log("========================================");
      console.log("YAZDIRMA BAŞARILI");
      console.log("========================================");

      return NextResponse.json<ApiResponse>({
        success: true,
        data: { message: "Yazdırma başarılı" },
      });
    } catch (printError: any) {
      console.error("========================================");
      console.error("YAZDIRMA HATASI - DETAYLI LOG");
      console.error("========================================");
      console.error("Hata mesajı:", printError.message);
      console.error("Hata stack:", printError.stack);
      console.error("Hata kodu:", printError.code);
      console.error("Hata errno:", printError.errno);
      console.error("Hata syscall:", printError.syscall);
      console.error("Yazıcı interface:", printerConfig.interface);
      console.error("Bağlantı tipi:", settings.connectionType);
      console.error(
        "Tam hata objesi:",
        JSON.stringify(printError, Object.getOwnPropertyNames(printError), 2)
      );
      console.error("========================================");
      return NextResponse.json<ApiResponse>({
        success: false,
        error: `Yazdırma hatası: ${printError.message}`,
      });
    }
  } catch (error: any) {
    console.error("========================================");
    console.error("API HATASI - DETAYLI LOG");
    console.error("========================================");
    console.error("Hata mesajı:", error.message);
    console.error("Hata stack:", error.stack);
    console.error("Hata tipi:", error.constructor.name);
    console.error(
      "Tam hata objesi:",
      JSON.stringify(error, Object.getOwnPropertyNames(error), 2)
    );
    console.error("Tam hata objesi:", safeStringifyError(error));
    console.error("========================================");
    return NextResponse.json<ApiResponse>({
      success: false,
      error: error.message || "Bilinmeyen bir hata oluştu",
    });
  }
}

function formatInterface(port: string): string {
  let cleanedPort = port.trim();

  if (!cleanedPort) {
    return port;
  }

  const platform = os.platform();

  if (cleanedPort.startsWith("tcp://") || cleanedPort.startsWith("printer:")) {
    return cleanedPort;
  }

  if (platform === "win32") {
    const serialMatch = cleanedPort.match(/^COM\d+$/i);
    if (serialMatch) {
      cleanedPort = `\\\\.\\${cleanedPort}`;
    }
  }

  return cleanedPort;
}

function safeStringifyError(error: any): string {
  try {
    return JSON.stringify(error, Object.getOwnPropertyNames(error), 2);
  } catch (stringifyError) {
    return `Hata string'e dönüştürülemedi: ${String(stringifyError)}`;
  }
}
